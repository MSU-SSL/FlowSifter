// This file is automatically generated from http.pac.

#include "http_pac_fast.h"

namespace binpac {

ExpectBody expect_reply_body(int reply_status)
	{

	// TODO: check if the request is "HEAD"
	if ( (reply_status >= 100 && reply_status < 200) ||
	     reply_status == 204 || reply_status == 304 )
		return BODY_NOT_EXPECTED;
	return BODY_EXPECTED;
	
	}

void extract_boundary(FastParser * t_fast_parser, const_bytestring const & value)
	{

	const char* boundary_prefix = "boundary=";	
	const char* boundary_begin = strcasestr(
					(const char*) value.begin(),
					boundary_prefix);
					

	if ( ! boundary_begin ) {
		//return bytestring();
		t_fast_parser->end_of_multipart_.set_length(0);
		return;
	}

	
	boundary_begin += 9;

	const char* boundary_end = strcasestr(boundary_begin, ";");
	if ( ! boundary_end ){
		boundary_end = (const char*) value.end();
	}
	

	//return bytestring((const uint8*) boundary_begin,
	//			(const uint8*) boundary_end);
	t_fast_parser->end_of_multipart_.init((const uint8*) boundary_begin,
					(const uint8*) boundary_end - (const uint8*) boundary_begin);
	
	}



//special function needed under Windows
int
strncasecmp(const char *s1, const char *s2, size_t n)
{
    while(n > 0
          && toupper((unsigned char)*s1) == toupper((unsigned char)*s2))
    {
        if(*s1 == '\0')
            return 0;
        s1++;
        s2++;
        n--;
    }
    if(n == 0)
        return 0;
    return toupper((unsigned char)*s1) - toupper((unsigned char)*s2);
}

//special function needed under Windows
char *
strcasestr(const char *s, const char *find)
{
        char c, sc;
        size_t len;

        if ((c = *find++) != 0) {
                c = (char)tolower((unsigned char)c);
                len = strlen(find);
                do {
                        do {
                                if ((sc = *s++) == 0)
                                        return (NULL);
                        } while ((char)tolower((unsigned char)sc) != c);
                } while (strncasecmp(s, find, len) != 0);
                s--;
        }
        return ((char *)s);
}

void testoutput(SimpleFlowBuffer* buffer_t, int field_length)
{
	
	for (int i = 0; i<field_length ; i++)	{
		printf("%c", *(buffer_t->data_begin+i));
	}
	
}

int decode_hex(char ch)
{
    if ( ch >= '0' && ch <= '9' )
        return ch - '0';

    if ( ch >= 'A' && ch <= 'F' )
        return ch - 'A' + 10;

    if ( ch >= 'a' && ch <= 'f' )
        return ch - 'a' + 10;

    return -1;
}

int is_reserved_URI_char(unsigned char ch)
{ // see RFC 2396 (definition of URI)
    return strchr(";/?:@&=+$,", ch) != 0;
}

int is_unreserved_URI_char(unsigned char ch)
{ // see RFC 2396 (definition of URI)
    return isalnum(ch) || strchr("-_.!~*\'()", ch) != 0;
}

int bytestring_to_int(const_bytestring const & s, int base)
{
	return strtol((const char*) std_str(s).c_str(), 0, base);
}

int bytestring_to_int(fast_parser_t s, int base)
{
	const_bytestring temp;
	temp.init(s->startptr, s->field_length);
	return strtol((const char*) std_str(temp).c_str(), 0, base);
}

int bytestring_casecmp(const_bytestring const & s1, const_charptr const & s2)
{
	int r = strncasecmp((const char*) s1.begin(), s2, s1.length());
	if ( r == 0 )
		return s2[s1.length()] == '\0' ? 0 : -1;
	else
		return r;
}

// True if s2 is a (case-insensitive) prefix of s1.
bool bytestring_caseprefix(const_bytestring const & s1, const_charptr const & s2)
{
	return strncasecmp((const char*) s1.begin(), s2, strlen(s2)) == 0;
}

double bytestring_to_double(const_bytestring const & s)
{
	return atof((const char*) std_str(s).c_str());
}

/* //newly modified
const_bytestring record_parsed_field(fast_parser_t t_fast_parser)
{
	return const_bytestring(t_fast_parser->flowbuffer->data_begin, t_fast_parser->field_length);
}*/

normal_bytestring record_parsed_field(fast_parser_t t_fast_parser)
{
	t_fast_parser->header_name_field.init(t_fast_parser->flowbuffer->data_begin, t_fast_parser->field_length);
	return t_fast_parser->header_name_field;
}

voidptr match_http_method(fast_parser_t t_fast_parser)
{
	matchHTTPMethod(t_fast_parser, (const char*)(t_fast_parser->flowbuffer->data_begin), (const char*)(t_fast_parser->flowbuffer->data_begin)+t_fast_parser->field_length, t_fast_parser->status == FastParser::NORMAL?true:false);
	return NULL;
}

voidptr match_http_uri(fast_parser_t t_fast_parser)
{
	matchHTTPUri(t_fast_parser, (const char*)(t_fast_parser->flowbuffer->data_begin), (const char*)(t_fast_parser->flowbuffer->data_begin)+t_fast_parser->field_length, t_fast_parser->status == FastParser::NORMAL?true:false);
	return NULL;
}

voidptr match_http_header_name(fast_parser_t t_fast_parser)
{
	int actual_length = t_fast_parser->field_length;
	if (actual_length > 0 && *((const char*)(t_fast_parser->flowbuffer->data_begin)+t_fast_parser->field_length-1) == ':')	{
		actual_length--;
		}
	matchHTTPHeaderName(t_fast_parser, (const char*)(t_fast_parser->flowbuffer->data_begin), (const char*)(t_fast_parser->flowbuffer->data_begin)+actual_length, t_fast_parser->status == FastParser::NORMAL?true:false);
	return NULL;
}

voidptr match_http_header_value(fast_parser_t t_fast_parser)
{
	matchHTTPHeaderValue(t_fast_parser, (const char*)(t_fast_parser->flowbuffer->data_begin), (const char*)(t_fast_parser->flowbuffer->data_begin)+t_fast_parser->field_length, t_fast_parser->status == FastParser::NORMAL?true:false);
	return NULL;
}

bool http_header(fast_parser_t t_fast_parser)
{
		if (t_fast_parser->status != FastParser::NORMAL)	{
			return false;
		}
		
		const_bytestring name(
			t_fast_parser->header_name_field.begin(),
			t_fast_parser->header_name_field.length() > 0 ?
				t_fast_parser->header_name_field.end() - 1 :
				t_fast_parser->header_name_field.end());
				
		const_bytestring value(t_fast_parser->startptr, t_fast_parser->field_length);

		if ( bytestring_casecmp(name, "CONTENT-LENGTH") == 0 )
			{
			t_fast_parser->content_length_ = bytestring_to_int(value, 10);
			t_fast_parser->delivery_mode_ = CONTENT_LENGTH;
			}

		else if ( bytestring_casecmp(name, "TRANSFER-ENCODING") == 0 )
			{
			if ( bytestring_caseprefix(value, "CHUNKED") )
				t_fast_parser->delivery_mode_ = CHUNKED;
			}

		else if ( bytestring_casecmp(name, "CONTENT-TYPE") == 0 )
			{
			if ( bytestring_caseprefix(value, "MULTIPART") )
				{
				//t_fast_parser->end_of_multipart_.free();	//newly modified
				//t_fast_parser->end_of_multipart_ = extract_boundary(value);
				extract_boundary(t_fast_parser, value);
				if ( t_fast_parser->end_of_multipart_.length() > 0 )
					t_fast_parser->delivery_mode_ = MULTIPART;
				}
			}

		return true;
}

int match_HTTP_token(simple_flow_buffer_t flowbuffer)
{
	//RE/[^()<>@,;:\\"\/\[\]?={} \t]+/
	int length = 0;
	while (flowbuffer->data_begin+length < flowbuffer->orig_end)
	{
		char temp = *(flowbuffer->data_begin+length);
		if (temp!='(' && temp!=')' && temp!='<' && temp!='>' && temp!='@' && temp!=',' && temp!=';' && temp!=':'
				&& temp!='\\' && temp!='\"' && temp!='/' && temp!='[' && temp!=']' && temp!='?' && temp!='='
				&& temp!='{' && temp!='}' && temp!=' ' && temp!='\t')
				{
					length++;
					}
		else	{
			break;
		}
		}
		if (length == 0)	{
			return -1;
		}
		else	{
			return length;
		}		
}

int match_HTTP_HEADER_NAME(simple_flow_buffer_t flowbuffer)
{
	//RE/([^: \t]+:)/
	int length = 0;
	while (flowbuffer->data_begin + length < flowbuffer->orig_end)	{
		char temp = *(flowbuffer->data_begin + length);
		if (temp != ':' && temp != ' ' && temp != '\t')	{
			length++;
			}
		else	{
			break;
		}
	}
	if (length == 0)	{
		return -1;
	}
	
	if (flowbuffer->data_begin + length < flowbuffer->orig_end && *(flowbuffer->data_begin+length) == ':')	{
		return length+1;
	}
	else	{
		return -1;
	}
}

#define INSET(B, x) ((B)[(x) >> 3] & 1 << ((x) & 0x07))

char PROTO_CHAR[128] = 
{
// 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// ' '  '!'  '"'  '#'  '$'  '%'  '&'  '''  '('  ')'  '*'  '+'  ','  '-'  '.'  '/'
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  ':'  ';'  '<'  '='  '>'  '?'
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// '@'  'A'  'B'  'C'  'D'  'E'  'F'  'G'  'H'  'I'  'J'  'K'  'L'  'M'  'N'  'O'
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    
// 'P'  'Q'  'R'  'S'  'T'  'U'  'V'  'W'  'X'  'Y'  'Z'  '['  '\'  ']'  '^'  '_'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   0,
    
// '`'  'a'  'b'  'c'  'd'  'e'  'f'  'g'  'h'  'i'  'j'  'k'  'l'  'm'  'n'  'o'
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,

// 'p'  'q'  'r'  's'  't'  'u'  'v'  'w'  'x'  'y'  'z'  '{'  '|'  '}'  '~'  0x7F
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   0
};

char HOST_CHAR[128] = 
{
// 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// ' '  '!'  '"'  '#'  '$'  '%'  '&'  '''  '('  ')'  '*'  '+'  ','  '-'  '.'  '/'
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   0,
    
// '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  ':'  ';'  '<'  '='  '>'  '?'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   0,
    
// '@'  'A'  'B'  'C'  'D'  'E'  'F'  'G'  'H'  'I'  'J'  'K'  'L'  'M'  'N'  'O'
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    
// 'P'  'Q'  'R'  'S'  'T'  'U'  'V'  'W'  'X'  'Y'  'Z'  '['  '\'  ']'  '^'  '_'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   0,
    
// '`'  'a'  'b'  'c'  'd'  'e'  'f'  'g'  'h'  'i'  'j'  'k'  'l'  'm'  'n'  'o'
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,

// 'p'  'q'  'r'  's'  't'  'u'  'v'  'w'  'x'  'y'  'z'  '{'  '|'  '}'  '~'  0x7F
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   0
};

char DIR_CHAR[128] = 
{
// 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// ' '  '!'  '"'  '#'  '$'  '%'  '&'  '''  '('  ')'  '*'  '+'  ','  '-'  '.'  '/'
    0,   1,   0,   0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,
    
// '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  ':'  ';'  '<'  '='  '>'  '?'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   1,   0,   0,
    
// '@'  'A'  'B'  'C'  'D'  'E'  'F'  'G'  'H'  'I'  'J'  'K'  'L'  'M'  'N'  'O'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    
// 'P'  'Q'  'R'  'S'  'T'  'U'  'V'  'W'  'X'  'Y'  'Z'  '['  '\'  ']'  '^'  '_'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   1,
    
// '`'  'a'  'b'  'c'  'd'  'e'  'f'  'g'  'h'  'i'  'j'  'k'  'l'  'm'  'n'  'o'
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,

// 'p'  'q'  'r'  's'  't'  'u'  'v'  'w'  'x'  'y'  'z'  '{'  '|'  '}'  '~'  0x7F
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   0
};

char VAR_CHAR[128] = 
{
// 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// ' '  '!'  '"'  '#'  '$'  '%'  '&'  '''  '('  ')'  '*'  '+'  ','  '-'  '.'  '/'
    0,   1,   0,   0,   1,   1,   0,   1,   1,   1,   1,   1,   1,   1,   1,   0,
    
// '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  ':'  ';'  '<'  '='  '>'  '?'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,
    
// '@'  'A'  'B'  'C'  'D'  'E'  'F'  'G'  'H'  'I'  'J'  'K'  'L'  'M'  'N'  'O'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    
// 'P'  'Q'  'R'  'S'  'T'  'U'  'V'  'W'  'X'  'Y'  'Z'  '['  '\'  ']'  '^'  '_'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   1,
    
// '`'  'a'  'b'  'c'  'd'  'e'  'f'  'g'  'h'  'i'  'j'  'k'  'l'  'm'  'n'  'o'
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,

// 'p'  'q'  'r'  's'  't'  'u'  'v'  'w'  'x'  'y'  'z'  '{'  '|'  '}'  '~'  0x7F
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   0
};

char VALUE_CHAR[128] = 
{
// 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// ' '  '!'  '"'  '#'  '$'  '%'  '&'  '''  '('  ')'  '*'  '+'  ','  '-'  '.'  '/'
    0,   1,   0,   0,   1,   1,   0,   1,   1,   1,   1,   1,   1,   1,   1,   0,
    
// '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  ':'  ';'  '<'  '='  '>'  '?'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   1,   0,   0,
    
// '@'  'A'  'B'  'C'  'D'  'E'  'F'  'G'  'H'  'I'  'J'  'K'  'L'  'M'  'N'  'O'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    
// 'P'  'Q'  'R'  'S'  'T'  'U'  'V'  'W'  'X'  'Y'  'Z'  '['  '\'  ']'  '^'  '_'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   1,
    
// '`'  'a'  'b'  'c'  'd'  'e'  'f'  'g'  'h'  'i'  'j'  'k'  'l'  'm'  'n'  'o'
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,

// 'p'  'q'  'r'  's'  't'  'u'  'v'  'w'  'x'  'y'  'z'  '{'  '|'  '}'  '~'  0x7F
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   1,   0,   0,   0
};

char FRAGMENT_CHAR[128] = 
{
// 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
// ' '  '!'  '"'  '#'  '$'  '%'  '&'  '''  '('  ')'  '*'  '+'  ','  '-'  '.'  '/'
    0,   1,   0,   0,   1,   0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    
// '0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  ':'  ';'  '<'  '='  '>'  '?'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   1,   0,   1,
    
// '@'  'A'  'B'  'C'  'D'  'E'  'F'  'G'  'H'  'I'  'J'  'K'  'L'  'M'  'N'  'O'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    
// 'P'  'Q'  'R'  'S'  'T'  'U'  'V'  'W'  'X'  'Y'  'Z'  '['  '\'  ']'  '^'  '_'
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   1,
    
// '`'  'a'  'b'  'c'  'd'  'e'  'f'  'g'  'h'  'i'  'j'  'k'  'l'  'm'  'n'  'o'
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,

// 'p'  'q'  'r'  's'  't'  'u'  'v'  'w'  'x'  'y'  'z'  '{'  '|'  '}'  '~'  0x7F
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   0,   0,   0,   0,   0
};

uint8 PROTO[16];
uint8 HOST[16];
uint8 DIR[16];
uint8 VAR[16];
uint8 VALUE[16];
uint8 FRAGMENT[16];

void init_bitmap(uint8 * bitmap, char * char_set)
{
    for(int i = 0; i < 128; i++)
    {
        if(char_set[i] == 0)
        {
            bitmap[i >> 3] &= ~(1 << (i & 0x07));
        }
        else
        {
            bitmap[i >> 3] |= (1 << (i & 0x07));
        }
    }
}

enum URI_PARSING_STATE
{
    ABS_PATH,
    DIRECTORY,
    EXPECT_QUERY,
    EXPECT_FRAGMENT,
    VAR_NAME,
    VAR_VALUE,
    FINISH,
    BAD,
};

uint32 parse_http_uri(simple_flow_buffer_t flowbuffer)
//uint32 parse_http_uri(uint8 * p_data_begin, uint32 data_length)
{
	uint8* p_data_begin = (uint8*)flowbuffer->data_begin;
	uint32 data_length = flowbuffer->orig_end - flowbuffer->data_begin;
	uint8 * p = p_data_begin;
	
	if(*p == '/')
	{
	    p += 1;
	    goto http_uri_abs_path;
	}
	else
	{
	    while(INSET(PROTO, *p))
	    {
	        p += 1;
        }
        
        //if(strncmpi((char *)p, "://", 3) != 0)
        if(strncasecmp((char *)p, "://", 3) != 0)      
        {
           // PRINTF("HTTP URI error!\n");
        }
        p += 3;
    }
    
    while(INSET(HOST, *p))
	{
	    p += 1;
    }
    
    if(*p == '/')
	{
	    p += 1;
	    goto http_uri_abs_path;
	}

http_uri_abs_path:

    URI_PARSING_STATE state = ABS_PATH;
    
    while(state != FINISH && state != BAD)
    {
        switch(state)
        {
        case ABS_PATH:
            if(*p == '#')
            {
                p += 1;
                state = EXPECT_FRAGMENT;
            }
            else if(*p == '?')
            {
                p += 1;
                state = EXPECT_QUERY;
            }
            else if(*p == ' ' || *p == '\t')
            {
                state = FINISH;
            }
            else if(INSET(DIR, *p))
            {
                state = DIRECTORY;
            }
            else
            {
                state = BAD;
            }
            break;
        case DIRECTORY:
            if(INSET(DIR, *p))
            {
                p += 1;
                state = DIRECTORY;
            }
            else if(*p == '/')
            {
                p += 1;
                state = ABS_PATH;
            }
            else if(*p == '#')
            {
                p += 1;
                state = EXPECT_FRAGMENT;
            }
            else if(*p == '?')
            {
                p += 1;
                state = EXPECT_QUERY;
            }
            else if(*p == ' ' || *p == '\t')
            {
                state = FINISH;
            }
            else
            {
                state = BAD;
            }
            break;
        case EXPECT_QUERY:
            if(INSET(VAR, *p))
            {
                state = VAR_NAME;
            }
            else if(*p == ' ' || *p == '\t')
            {
                state = FINISH;
            }
            else
            {
                state = BAD;
            }
            break;
        case EXPECT_FRAGMENT:
            if(INSET(FRAGMENT, *p))
            {
                p += 1;
                state = EXPECT_FRAGMENT;
            }
            else if(*p == ' ' || *p == '\t')
            {
                state = FINISH;
            }
            else
            {
                state = BAD;
            }
            break;
        case VAR_NAME:
            if(INSET(VAR, *p))
            {
                p += 1;
                state = VAR_NAME;
            }
            else if(*p == '=')
            {
                p += 1;
                state = VAR_VALUE;
            }
            else
            {
                state = BAD;
            }
            break;
        case VAR_VALUE:
            if(INSET(VALUE, *p))
            {
                p += 1;
                state = VAR_VALUE;
            }
            else if(*p == '#')
            {
                p += 1;
                state = EXPECT_FRAGMENT;
            }
            else if(*p == '&')
            {
                p += 1;
                state = EXPECT_QUERY;
            }
            else if(*p == ' ' || *p == '\t')
            {
                state = FINISH;
            }
            else
            {
                state = BAD;
            }
            break;
        case FINISH:
            break;
        default:
            break;
        };
    }

    return p - p_data_begin;    
}

RegExMatcher regexmatcher_1("[^]()<>@,;:\\\"/\\[?={} \\t]+");
RegExMatcher regexmatcher_2("[ \\t]*");
RegExMatcher regexmatcher_3("\\([]a-zA-Z0-9`~!@#$%^&*()_+=\\[{}\\\\\\|;':\",-./<>?]\\|[^\x01-\x7f]\\)+[ \\t]*");
RegExMatcher regexmatcher_4("[ \\t]*");
RegExMatcher regexmatcher_5("[ \\t]*");
RegExMatcher regexmatcher_8("[0-9]+\\.[0-9]+");
RegExMatcher regexmatcher_12("[0-9]+\\.[0-9]+");
RegExMatcher regexmatcher_13("[0-9]{3}");
RegExMatcher regexmatcher_16("([^: \\t]+:)");
RegExMatcher regexmatcher_17("[ \\t]*");
RegExMatcher regexmatcher_20("([^: \\t]+:)");
RegExMatcher regexmatcher_21("[ \\t]*");
RegExMatcher regexmatcher_36("([^: \\t]+:)");
RegExMatcher regexmatcher_37("[ \\t]*");
RegExMatcher regexmatcher_41("([^: \\t]+:)");
RegExMatcher regexmatcher_42("[ \\t]*");

bool FastParser::is_end_of_multipart(SimpleFlowBuffer * t_flow_buffer)
	{

	const_byteptr t_end_of_data = t_flow_buffer->end();
	const_bytestring line(startptr, t_end_of_data);
	if ( line.length() < 4 + end_of_multipart_.length() )
		return false;
	int len = end_of_multipart_.length();

	// line =?= "--" end_of_multipart_ "--"
	return ( line[0] == '-' && line[1] == '-' &&
	line[len + 2] == '-' && line[len + 3] == '-' &&
	strncmp((const char*) line.begin() + 2,
	(const char*) end_of_multipart_.begin(),len) == 0 );
		
	}

void FastParser::FuncParsingFlow()
{
	this->startptr = flowbuffer->begin();
	FuncParsingPDU();
	while (this->status== FastParser::PARSING_COMPLETE)	{
		this->tablepointer = 0;
		this->status = NORMAL;
		this->startptr = flowbuffer->begin();
		this->content_length_ = 0;
		this->delivery_mode_ = UNKNOWN_DELIVERY_MODE;
		this->field_length_left = 0;
		FuncParsingPDU();
	}

}

int FastParser::FuncParsingPDU()
{
	switch (status)	{
		case BAD: return tablepointer; break;
		case PARSING_COMPLETE: return -1;
		default: break;
	}

	switch (tablepointer)	{
		case 0: goto parse_field_0; break;
		case 1: goto parse_field_1; break;
		case 2: goto parse_field_2; break;
		case 3: goto parse_field_3; break;
		case 4: goto parse_field_4; break;
		case 5: goto parse_field_5; break;
		case 6: goto parse_field_6; break;
		case 7: goto parse_field_7; break;
		case 8: goto parse_field_8; break;
		case 9: goto parse_field_9; break;
		case 10: goto parse_field_10; break;
		case 11: goto parse_field_11; break;
		case 12: goto parse_field_12; break;
		case 13: goto parse_field_13; break;
		case 14: goto parse_field_14; break;
		case 15: goto parse_field_15; break;
		case 16: goto parse_field_16; break;
		case 17: goto parse_field_17; break;
		case 18: goto parse_field_18; break;
		case 19: goto parse_field_19; break;
		case 20: goto parse_field_20; break;
		case 21: goto parse_field_21; break;
		case 22: goto parse_field_22; break;
		case 23: goto parse_field_23; break;
		case 24: goto parse_field_24; break;
		case 25: goto parse_field_25; break;
		case 26: goto parse_field_26; break;
		case 27: goto parse_field_27; break;
		case 28: goto parse_field_28; break;
		case 29: goto parse_field_29; break;
		case 30: goto parse_field_30; break;
		case 31: goto parse_field_31; break;
		case 32: goto parse_field_32; break;
		case 33: goto parse_field_33; break;
		case 34: goto parse_field_34; break;
		case 35: goto parse_field_35; break;
		case 36: goto parse_field_36; break;
		case 37: goto parse_field_37; break;
		case 38: goto parse_field_38; break;
		case 39: goto parse_field_39; break;
		case 40: goto parse_field_40; break;
		case 41: goto parse_field_41; break;
		case 42: goto parse_field_42; break;
		case 43: goto parse_field_43; break;
		case 44: goto parse_field_44; break;
		case 45: goto parse_field_45; break;
		case 46: goto parse_field_46; break;
		case 47: goto parse_field_47; break;
		case -1: status = PARSING_COMPLETE; return -1; break;
		default: status = BAD; return 0; break;
	}

parse_field_0:
	field_length = 0;
	//update context
	status = NORMAL;
	
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch (is_orig)	{
		case true:
			tablepointer = 1;
			break;
		case false:
			tablepointer = 11;
			goto parse_field_11;
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 0;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_1:
	field_length = regexmatcher_1.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 1; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 1; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	matchresult = match_http_method(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 2;
parse_field_2:
	field_length = regexmatcher_2.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 2; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 2; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 3;
parse_field_3:
	field_length = regexmatcher_3.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 3; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 3; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	matchresult = match_http_uri(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 7;
	goto parse_field_7;
parse_field_4:
	field_length = regexmatcher_4.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 4; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 4; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 13;
	goto parse_field_13;
parse_field_5:
	field_length = regexmatcher_5.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 5; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 5; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 6;
parse_field_6:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 6; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	expect_body = expect_reply_body(stat_num);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 14;
	goto parse_field_14;
parse_field_7:
	if (status == NORMAL)	{	//handling starting of a new field
		field_length_left = 5;
	}
	if (flowbuffer->data_begin+field_length_left> flowbuffer->orig_end) {
		field_length = flowbuffer->orig_end - flowbuffer->data_begin;
		field_length_left-=field_length;
		status = INCOMPLETE_FIELD;
		//update context
		flowbuffer->data_begin+=field_length;
		startptr=flowbuffer->data_begin;
		return 7; //return a positive number means parsing error on this field
	}
	else {
		field_length = field_length_left;
		field_length_left-=field_length;
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 8;
parse_field_8:
	field_length = regexmatcher_8.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 8; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length +1 >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 8; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	expect_body = BODY_MAYBE;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 9;
parse_field_9:
	field_length = 0;
	if (flowbuffer->data_begin < flowbuffer->orig_end-2)	{
		flowbuffer->TestOneline();
	}
	else	{
	status = INCOMPLETE_FIELD;
	return 9; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( flowbuffer->length() == 0 ) )	{
		case 0:
			tablepointer = 16;
			goto parse_field_16;
			break;
		case 1:
			switch (expect_body)	{
				case BODY_NOT_EXPECTED:
					tablepointer = 10;
					break;
				default:
					switch (this->delivery_mode_)	{
						case CONTENT_LENGTH:
							tablepointer = 19;
							goto parse_field_19;
							break;
						case CHUNKED:
							tablepointer = 34;
							goto parse_field_34;
							break;
						case MULTIPART:
							tablepointer = 24;
							goto parse_field_24;
							break;
						default:
							switch (expect_body)	{
								case BODY_MAYBE:
								case BODY_NOT_EXPECTED:
									tablepointer = 25;
									goto parse_field_25;
									break;
								case BODY_EXPECTED:
									tablepointer = 26;
									goto parse_field_26;
									break;
								default:
									//cout <<"unexpected case, exiting"<<endl;
									status = BAD;
									return 9;	//return a positive number mean parsing error in this field
									break;
							}
							break;
					}
					break;
			}
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 9;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_10:
	field_length = 0;
	//update context
	status = NORMAL;
	
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = -1;
	goto parse_PDU_complete;
parse_field_11:
	if (status == NORMAL)	{	//handling starting of a new field
		field_length_left = 5;
	}
	if (flowbuffer->data_begin+field_length_left> flowbuffer->orig_end) {
		field_length = flowbuffer->orig_end - flowbuffer->data_begin;
		field_length_left-=field_length;
		status = INCOMPLETE_FIELD;
		//update context
		flowbuffer->data_begin+=field_length;
		startptr=flowbuffer->data_begin;
		return 11; //return a positive number means parsing error on this field
	}
	else {
		field_length = field_length_left;
		field_length_left-=field_length;
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 12;
parse_field_12:
	field_length = regexmatcher_12.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 12; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 12; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 4;
	goto parse_field_4;
parse_field_13:
	field_length = regexmatcher_13.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 13; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 13; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	stat_num = bytestring_to_int(this, 10);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 5;
	goto parse_field_5;
parse_field_14:
	field_length = 0;
	if (flowbuffer->data_begin < flowbuffer->orig_end-2)	{
		flowbuffer->TestOneline();
	}
	else	{
	status = INCOMPLETE_FIELD;
	return 14; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( flowbuffer->length() == 0 ) )	{
		case 0:
			tablepointer = 20;
			goto parse_field_20;
			break;
		case 1:
			switch (expect_body)	{
				case BODY_NOT_EXPECTED:
					tablepointer = 15;
					break;
				default:
					switch (this->delivery_mode_)	{
						case CONTENT_LENGTH:
							tablepointer = 23;
							goto parse_field_23;
							break;
						case CHUNKED:
							tablepointer = 39;
							goto parse_field_39;
							break;
						case MULTIPART:
							tablepointer = 27;
							goto parse_field_27;
							break;
						default:
							switch (expect_body)	{
								case BODY_MAYBE:
								case BODY_NOT_EXPECTED:
									tablepointer = 28;
									goto parse_field_28;
									break;
								case BODY_EXPECTED:
									tablepointer = 29;
									goto parse_field_29;
									break;
								default:
									//cout <<"unexpected case, exiting"<<endl;
									status = BAD;
									return 14;	//return a positive number mean parsing error in this field
									break;
							}
							break;
					}
					break;
			}
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 14;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_15:
	field_length = 0;
	//update context
	status = NORMAL;
	
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = -1;
	goto parse_PDU_complete;
parse_field_16:
	field_length = regexmatcher_16.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 16; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 16; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	header_name_field = record_parsed_field(this);
	matchresult = match_http_header_name(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 17;
parse_field_17:
	field_length = regexmatcher_17.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 17; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 17; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 18;
parse_field_18:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 18; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	process_header = http_header(this);
	matchresult = match_http_header_value(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 9;
	goto parse_field_9;
parse_field_19:
	if (status == NORMAL)	{	//handling starting of a new field
		field_length_left = this->content_length_;
	}
	if (flowbuffer->data_begin+field_length_left> flowbuffer->orig_end) {
		field_length = flowbuffer->orig_end - flowbuffer->data_begin;
		field_length_left-=field_length;
		status = INCOMPLETE_FIELD;
		//update context
		flowbuffer->data_begin+=field_length;
		startptr=flowbuffer->data_begin;
		return 19; //return a positive number means parsing error on this field
	}
	else {
		field_length = field_length_left;
		field_length_left-=field_length;
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = -1;
	goto parse_PDU_complete;
parse_field_20:
	field_length = regexmatcher_20.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 20; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 20; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	header_name_field = record_parsed_field(this);
	matchresult = match_http_header_name(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 21;
parse_field_21:
	field_length = regexmatcher_21.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 21; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 21; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 22;
parse_field_22:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 22; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	process_header = http_header(this);
	matchresult = match_http_header_value(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 14;
	goto parse_field_14;
parse_field_23:
	if (status == NORMAL)	{	//handling starting of a new field
		field_length_left = this->content_length_;
	}
	if (flowbuffer->data_begin+field_length_left> flowbuffer->orig_end) {
		field_length = flowbuffer->orig_end - flowbuffer->data_begin;
		field_length_left-=field_length;
		status = INCOMPLETE_FIELD;
		//update context
		flowbuffer->data_begin+=field_length;
		startptr=flowbuffer->data_begin;
		return 23; //return a positive number means parsing error on this field
	}
	else {
		field_length = field_length_left;
		field_length_left-=field_length;
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = -1;
	goto parse_PDU_complete;
parse_field_24:
	field_length = 0;
	if (flowbuffer->data_begin < flowbuffer->orig_end-2)	{
		flowbuffer->TestOneline();
	}
	else	{
	status = INCOMPLETE_FIELD;
	return 24; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( this->is_end_of_multipart(flowbuffer) ) )	{
		case 0:
			tablepointer = 31;
			goto parse_field_31;
			break;
		case 1:
			tablepointer = -1;
			goto parse_PDU_complete;
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 24;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_25:
	field_length = 0;
	//update context
	status = NORMAL;
	
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = -1;
	goto parse_PDU_complete;
parse_field_26:
	field_length = flowbuffer->orig_end - flowbuffer->data_begin;
	//update context
	status = REST_OF_FLOW;
	flowbuffer->data_begin+=field_length;
	startptr=flowbuffer->data_begin;
	return 26; //return a positive number means parsing error on this field
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = -1;
	goto parse_PDU_complete;
parse_field_27:
	field_length = 0;
	if (flowbuffer->data_begin < flowbuffer->orig_end-2)	{
		flowbuffer->TestOneline();
	}
	else	{
	status = INCOMPLETE_FIELD;
	return 27; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( this->is_end_of_multipart(flowbuffer) ) )	{
		case 0:
			tablepointer = 33;
			goto parse_field_33;
			break;
		case 1:
			tablepointer = -1;
			goto parse_PDU_complete;
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 27;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_28:
	field_length = 0;
	//update context
	status = NORMAL;
	
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = -1;
	goto parse_PDU_complete;
parse_field_29:
	field_length = flowbuffer->orig_end - flowbuffer->data_begin;
	//update context
	status = REST_OF_FLOW;
	flowbuffer->data_begin+=field_length;
	startptr=flowbuffer->data_begin;
	return 29; //return a positive number means parsing error on this field
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = -1;
	goto parse_PDU_complete;
parse_field_30:
	field_length = 0;
	if (flowbuffer->data_begin < flowbuffer->orig_end-2)	{
		flowbuffer->TestOneline();
	}
	else	{
	status = INCOMPLETE_FIELD;
	return 30; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( flowbuffer->length() == 0 ) )	{
		case 0:
			tablepointer = 36;
			goto parse_field_36;
			break;
		case 1:
			tablepointer = -1;
			goto parse_PDU_complete;
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 30;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_31:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 31; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 24;
	goto parse_field_24;
parse_field_32:
	field_length = 0;
	if (flowbuffer->data_begin < flowbuffer->orig_end-2)	{
		flowbuffer->TestOneline();
	}
	else	{
	status = INCOMPLETE_FIELD;
	return 32; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( flowbuffer->length() == 0 ) )	{
		case 0:
			tablepointer = 41;
			goto parse_field_41;
			break;
		case 1:
			tablepointer = -1;
			goto parse_PDU_complete;
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 32;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_33:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 33; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 27;
	goto parse_field_27;
parse_field_34:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 34; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	chunk_length = bytestring_to_int(this, 16);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 35;
parse_field_35:
	if (status == NORMAL)	{	//handling starting of a new field
		field_length_left = chunk_length;
	}
	if (flowbuffer->data_begin+field_length_left> flowbuffer->orig_end) {
		field_length = flowbuffer->orig_end - flowbuffer->data_begin;
		field_length_left-=field_length;
		status = INCOMPLETE_FIELD;
		//update context
		flowbuffer->data_begin+=field_length;
		startptr=flowbuffer->data_begin;
		return 35; //return a positive number means parsing error on this field
	}
	else {
		field_length = field_length_left;
		field_length_left-=field_length;
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch (chunk_length)	{
		case 0:
			tablepointer = 44;
			goto parse_field_44;
			break;
		default:
			tablepointer = 45;
			goto parse_field_45;
			break;
	}
parse_field_36:
	field_length = regexmatcher_36.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 36; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 36; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	header_name_field = record_parsed_field(this);
	matchresult = match_http_header_name(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 37;
parse_field_37:
	field_length = regexmatcher_37.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 37; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 37; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 38;
parse_field_38:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 38; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	process_header = http_header(this);
	matchresult = match_http_header_value(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 30;
	goto parse_field_30;
parse_field_39:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 39; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	chunk_length = bytestring_to_int(this, 16);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 40;
parse_field_40:
	if (status == NORMAL)	{	//handling starting of a new field
		field_length_left = chunk_length;
	}
	if (flowbuffer->data_begin+field_length_left> flowbuffer->orig_end) {
		field_length = flowbuffer->orig_end - flowbuffer->data_begin;
		field_length_left-=field_length;
		status = INCOMPLETE_FIELD;
		//update context
		flowbuffer->data_begin+=field_length;
		startptr=flowbuffer->data_begin;
		return 40; //return a positive number means parsing error on this field
	}
	else {
		field_length = field_length_left;
		field_length_left-=field_length;
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch (chunk_length)	{
		case 0:
			tablepointer = 46;
			goto parse_field_46;
			break;
		default:
			tablepointer = 47;
			goto parse_field_47;
			break;
	}
parse_field_41:
	field_length = regexmatcher_41.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 41; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 41; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	header_name_field = record_parsed_field(this);
	matchresult = match_http_header_name(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 42;
parse_field_42:
	field_length = regexmatcher_42.MatchPrefix(flowbuffer->data_begin, flowbuffer->orig_end - flowbuffer->data_begin);
	if (field_length < 0) {
		if (flowbuffer->orig_end - flowbuffer->data_begin < 20) {
			status = INCOMPLETE_FIELD;
		}
		else {
			status = BAD;
		}
		return 42; //return a positive number means parsing error on this field
	}
	if (flowbuffer->data_begin+field_length >= flowbuffer->orig_end)	{
		status = INCOMPLETE_FIELD;
		return 42; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 43;
parse_field_43:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 43; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	process_header = http_header(this);
	matchresult = match_http_header_value(this);
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	tablepointer = 32;
	goto parse_field_32;
parse_field_44:
	field_length = 0;
	//update context
	status = NORMAL;
	
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( chunk_length == 0 ) )	{
		case 0:
			tablepointer = 34;
			goto parse_field_34;
			break;
		case 1:
			tablepointer = 30;
			goto parse_field_30;
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 44;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_45:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 45; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( chunk_length == 0 ) )	{
		case 0:
			tablepointer = 34;
			goto parse_field_34;
			break;
		case 1:
			tablepointer = 30;
			goto parse_field_30;
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 45;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_46:
	field_length = 0;
	//update context
	status = NORMAL;
	
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( chunk_length == 0 ) )	{
		case 0:
			tablepointer = 39;
			goto parse_field_39;
			break;
		case 1:
			tablepointer = 32;
			goto parse_field_32;
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 46;	//return a positive number mean parsing error in this field
			break;
	}
parse_field_47:
	field_length = flowbuffer->Oneline();
	if (flowbuffer->data_begin+field_length +1>= flowbuffer->orig_end)	{	//allow the ending CRLF
		status = INCOMPLETE_FIELD;
		return 47; //return a positive number means parsing error on this field
	}
	//update context
	status = NORMAL;
	
	flowbuffer->data_begin+=field_length;
	startptr = flowbuffer->data_begin;
	if (flowbuffer->CleanUpNewLine())	{
	}
	//compute garbage length
	//no garbage length in the current implementation

	//compute next field
	switch ( ( chunk_length == 0 ) )	{
		case 0:
			tablepointer = 39;
			goto parse_field_39;
			break;
		case 1:
			tablepointer = 32;
			goto parse_field_32;
			break;
		default:
			//cout <<"unexpected case, exiting"<<endl;
			status = BAD;
			return 47;	//return a positive number mean parsing error in this field
			break;
	}
	parse_PDU_complete:
	status = PARSING_COMPLETE;
	return -1;
}

Metadata FastParser::metadata[48] = {Metadata("HTTP_PDU"), Metadata("method"), Metadata("anonymous_field_004"), Metadata("uri"), Metadata("anonymous_field_005"), Metadata("anonymous_field_006"), Metadata("reason"), Metadata("anonymous_field_008"), Metadata("vers_str"), Metadata("array_header"), Metadata("none"), Metadata("anonymous_field_008"), Metadata("vers_str"), Metadata("stat_str"), Metadata("array_header"), Metadata("none"), Metadata("name"), Metadata("anonymous_field_011"), Metadata("value"), Metadata("body"), Metadata("name"), Metadata("anonymous_field_011"), Metadata("value"), Metadata("body"), Metadata("array_header"), Metadata("maybenot"), Metadata("rest"), Metadata("array_header"), Metadata("maybenot"), Metadata("rest"), Metadata("array_header"), Metadata("line"), Metadata("array_header"), Metadata("line"), Metadata("length_line"), Metadata("data"), Metadata("name"), Metadata("anonymous_field_011"), Metadata("value"), Metadata("length_line"), Metadata("data"), Metadata("name"), Metadata("anonymous_field_011"), Metadata("value"), Metadata("none"), Metadata("crlf"), Metadata("none"), Metadata("crlf")};

FieldType FastParser::fieldtype[48] = {TYPE2, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1, TYPE1};

}  // namespace binpac
