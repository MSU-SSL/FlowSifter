// This file is automatically generated from http.pac.

#include "http_pac.h"

namespace binpac {

std::string std_string(const_bytestring const & s)
	{
	return std::string((const char *) s.begin(), (const char *) s.end());
	}


int bytestring_casecmp(const_bytestring const & s1, const_charptr const & s2)
	{

	int r = strncasecmp((const char*) s1.begin(), s2, s1.length());
	if ( r == 0 )
		return s2[s1.length()] == '\0' ? 0 : -1;
	else
		return r;
	
	}

bool bytestring_caseprefix(const_bytestring const & s1, const_charptr const & s2)
	{

	return strncasecmp((const char*) s1.begin(), s2, strlen(s2)) == 0;
	
	}

int bytestring_to_int(const_bytestring const & s, int base)
	{

	return strtol((const char*) std_str(s).c_str(), 0, base);
	
	}

double bytestring_to_double(const_bytestring const & s)
	{

	return atof((const char*) std_str(s).c_str());
	
	}

namespace HTTP {
ContextHTTP::ContextHTTP(HTTP_Conn * connection, HTTP_Flow * flow, FlowBuffer * flow_buffer)
	{
	connection_ = connection;
	flow_ = flow;
	flow_buffer_ = flow_buffer;
	}

ContextHTTP::~ContextHTTP()
	{
	}

RegExMatcher HTTP_TOKEN_re_001("[^()<>@,;:\\\"/\\[\\]?={} \\t]+");

RegExMatcher HTTP_WS_re_002("[ \\t]*");

RegExMatcher HTTP_URI_re_003("[[:alnum:][:punct:]]+");

HTTP_PDU::HTTP_PDU(bool is_orig)
	{
	val_case_index_ = -1;
	request_ = 0;
	reply_ = 0;
	is_orig_ = is_orig;
	}

HTTP_PDU::~HTTP_PDU()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "reply"
			{
			delete reply_;
			reply_ = 0;
			}
			break;
		}
	}

bool HTTP_PDU::ParseBuffer(flow_buffer_t t_flow_buffer, ContextHTTP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "request"
			{
			if ( ! request_ )
				{
				request_ = new HTTP_Request();
				}
			bool t_request_parsing_complete;
			t_request_parsing_complete = false;
			t_request_parsing_complete = request_->ParseBuffer(t_flow_buffer, t_context);
			if ( t_request_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			t_val_parsing_complete = t_request_parsing_complete;
			}
			break;
		case 0:
			// Parse "reply"
			{
			if ( ! reply_ )
				{
				reply_ = new HTTP_Reply();
				}
			bool t_reply_parsing_complete;
			t_reply_parsing_complete = false;
			t_reply_parsing_complete = reply_->ParseBuffer(t_flow_buffer, t_context);
			if ( t_reply_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			t_val_parsing_complete = t_reply_parsing_complete;
			}
			break;
		default:
			throw ExceptionInvalidCaseIndex("HTTP_PDU", val_case_index());
			break;
		}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	return t_val_parsing_complete;
	}

HTTP_Request::HTTP_Request()
	{
	request_ = 0;
	buffering_state_ = 0;
	msg_ = 0;
	parsing_state_ = 0;
	}

HTTP_Request::~HTTP_Request()
	{
	delete request_;
	request_ = 0;
	delete msg_;
	msg_ = 0;
	}

bool HTTP_Request::ParseBuffer(flow_buffer_t t_flow_buffer, ContextHTTP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "request"
		if ( ! request_ )
			{
			request_ = new HTTP_RequestLine();
			}
		if ( buffering_state_ == 0 )
			{
			t_flow_buffer->NewLine();
			buffering_state_ = 1;
			}
		parsing_state_ = 1;
	case 1:
		{
		bool t_request_parsing_complete;
		t_request_parsing_complete = false;
		while ( ! t_request_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			t_request_parsing_complete = request_->ParseBuffer(t_flow_buffer, t_context);
			if ( t_request_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			buffering_state_ = 0;
			}
		if ( ! (t_request_parsing_complete) )
			goto need_more_data;
		}
		
		// Parse "msg"
		if ( ! msg_ )
			{
			msg_ = new HTTP_Message(BODY_MAYBE);
			}
		parsing_state_ = 2;
	case 2:
		{
		bool t_msg_parsing_complete;
		t_msg_parsing_complete = false;
		t_msg_parsing_complete = msg_->ParseBuffer(t_flow_buffer, t_context);
		if ( t_msg_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_msg_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

ExpectBody expect_reply_body(int reply_status)
	{

  // TODO: check if the request is "HEAD"
  if ( (reply_status >= 100 && reply_status < 200) ||
       reply_status == 204 || reply_status == 304 )
    return BODY_NOT_EXPECTED;
  return BODY_EXPECTED;
  
	}

HTTP_Reply::HTTP_Reply()
	{
	reply_ = 0;
	buffering_state_ = 0;
	msg_ = 0;
	parsing_state_ = 0;
	}

HTTP_Reply::~HTTP_Reply()
	{
	delete reply_;
	reply_ = 0;
	delete msg_;
	msg_ = 0;
	}

bool HTTP_Reply::ParseBuffer(flow_buffer_t t_flow_buffer, ContextHTTP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "reply"
		if ( ! reply_ )
			{
			reply_ = new HTTP_ReplyLine();
			}
		if ( buffering_state_ == 0 )
			{
			t_flow_buffer->NewLine();
			buffering_state_ = 1;
			}
		parsing_state_ = 1;
	case 1:
		{
		bool t_reply_parsing_complete;
		t_reply_parsing_complete = false;
		while ( ! t_reply_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			t_reply_parsing_complete = reply_->ParseBuffer(t_flow_buffer);
			if ( t_reply_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			buffering_state_ = 0;
			}
		if ( ! (t_reply_parsing_complete) )
			goto need_more_data;
		}
		
		// Parse "msg"
		if ( ! msg_ )
			{
			msg_ = new HTTP_Message(expect_reply_body(reply()->status()->stat_num()));
			}
		parsing_state_ = 2;
	case 2:
		{
		bool t_msg_parsing_complete;
		t_msg_parsing_complete = false;
		t_msg_parsing_complete = msg_->ParseBuffer(t_flow_buffer, t_context);
		if ( t_msg_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_msg_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

HTTP_RequestLine::HTTP_RequestLine()
	{
	version_ = 0;
	buffering_state_ = 0;
	}

HTTP_RequestLine::~HTTP_RequestLine()
	{
	method_.free();
	uri_.free();
	delete version_;
	version_ = 0;
	}

bool HTTP_RequestLine::ParseBuffer(flow_buffer_t t_flow_buffer, ContextHTTP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	// Parse "method"
	int t_method_string_length;
	t_method_string_length = 
		HTTP_TOKEN_re_001.MatchPrefix(
			t_begin_of_data,
			t_end_of_data - t_begin_of_data);
	if ( t_method_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:69", "[^()<>@,;:\\\"/\\[\\]?={} \\t]+", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	int t_method__size;
	t_method__size = t_method_string_length;
	// check for negative sizes
	if ( t_method_string_length < 0 )
	throw ExceptionInvalidStringLength("http.pac:69", t_method_string_length);
	method_.init(t_begin_of_data, t_method_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_method = t_begin_of_data + (t_method__size);
	BINPAC_ASSERT(t_dataptr_after_method <= t_end_of_data);
	// Parse "anonymous_field_004"
	bytestring anonymous_field_004_;
	int t_anonymous_field_004_string_length;
	t_anonymous_field_004_string_length = 
		HTTP_WS_re_002.MatchPrefix(
			t_dataptr_after_method,
			t_end_of_data - t_dataptr_after_method);
	if ( t_anonymous_field_004_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:70", "[ \\t]*", string((const char *) (t_dataptr_after_method), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_004__size;
	t_anonymous_field_004__size = t_anonymous_field_004_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_004_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_004 = t_dataptr_after_method + (t_anonymous_field_004__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_004 <= t_end_of_data);
	// Parse "uri"
	int t_uri_string_length;
	t_uri_string_length = 
		HTTP_URI_re_003.MatchPrefix(
			t_dataptr_after_anonymous_field_004,
			t_end_of_data - t_dataptr_after_anonymous_field_004);
	if ( t_uri_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:71", "[[:alnum:][:punct:]]+", string((const char *) (t_dataptr_after_anonymous_field_004), (const char *) t_end_of_data).c_str());
		}
	int t_uri__size;
	t_uri__size = t_uri_string_length;
	// check for negative sizes
	if ( t_uri_string_length < 0 )
	throw ExceptionInvalidStringLength("http.pac:71", t_uri_string_length);
	uri_.init(t_dataptr_after_anonymous_field_004, t_uri_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_uri = t_dataptr_after_anonymous_field_004 + (t_uri__size);
	BINPAC_ASSERT(t_dataptr_after_uri <= t_end_of_data);
	// Parse "anonymous_field_005"
	bytestring anonymous_field_005_;
	int t_anonymous_field_005_string_length;
	t_anonymous_field_005_string_length = 
		HTTP_WS_re_002.MatchPrefix(
			t_dataptr_after_uri,
			t_end_of_data - t_dataptr_after_uri);
	if ( t_anonymous_field_005_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:72", "[ \\t]*", string((const char *) (t_dataptr_after_uri), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_005__size;
	t_anonymous_field_005__size = t_anonymous_field_005_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_005_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_005 = t_dataptr_after_uri + (t_anonymous_field_005__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_005 <= t_end_of_data);
	// Parse "version"
	version_ = new HTTP_Version();
	int t_version__size;
	t_version__size = version_->Parse(t_dataptr_after_anonymous_field_005, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	t_val_parsing_complete = true;
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		process_request_ = scb_store_method_uri_version(t_context->connection()->http_conn(), t_context->flow()->is_orig(), method(), uri(), version()->vers_str());
		}
	buffering_state_ = 0;
	return t_val_parsing_complete;
	}

HTTP_ReplyLine::HTTP_ReplyLine()
	{
	version_ = 0;
	status_ = 0;
	buffering_state_ = 0;
	}

HTTP_ReplyLine::~HTTP_ReplyLine()
	{
	delete version_;
	version_ = 0;
	delete status_;
	status_ = 0;
	reason_.free();
	}

bool HTTP_ReplyLine::ParseBuffer(flow_buffer_t t_flow_buffer)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	// Parse "version"
	version_ = new HTTP_Version();
	int t_version__size;
	t_version__size = version_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_version = t_begin_of_data + (t_version__size);
	BINPAC_ASSERT(t_dataptr_after_version <= t_end_of_data);
	// Parse "anonymous_field_006"
	bytestring anonymous_field_006_;
	int t_anonymous_field_006_string_length;
	t_anonymous_field_006_string_length = 
		HTTP_WS_re_002.MatchPrefix(
			t_dataptr_after_version,
			t_end_of_data - t_dataptr_after_version);
	if ( t_anonymous_field_006_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:78", "[ \\t]*", string((const char *) (t_dataptr_after_version), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_006__size;
	t_anonymous_field_006__size = t_anonymous_field_006_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_006_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_006 = t_dataptr_after_version + (t_anonymous_field_006__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_006 <= t_end_of_data);
	// Parse "status"
	status_ = new HTTP_Status();
	int t_status__size;
	t_status__size = status_->Parse(t_dataptr_after_anonymous_field_006, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_status = t_dataptr_after_anonymous_field_006 + (t_status__size);
	BINPAC_ASSERT(t_dataptr_after_status <= t_end_of_data);
	// Parse "anonymous_field_007"
	bytestring anonymous_field_007_;
	int t_anonymous_field_007_string_length;
	t_anonymous_field_007_string_length = 
		HTTP_WS_re_002.MatchPrefix(
			t_dataptr_after_status,
			t_end_of_data - t_dataptr_after_status);
	if ( t_anonymous_field_007_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:80", "[ \\t]*", string((const char *) (t_dataptr_after_status), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_007__size;
	t_anonymous_field_007__size = t_anonymous_field_007_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_007_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_007 = t_dataptr_after_status + (t_anonymous_field_007__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_007 <= t_end_of_data);
	// Parse "reason"
	int t_reason_string_length;
	t_reason_string_length = (t_end_of_data) - (t_dataptr_after_anonymous_field_007);
	int t_reason__size;
	t_reason__size = t_reason_string_length;
	// check for negative sizes
	if ( t_reason_string_length < 0 )
	throw ExceptionInvalidStringLength("http.pac:81", t_reason_string_length);
	reason_.init(t_dataptr_after_anonymous_field_007, t_reason_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	t_val_parsing_complete = true;
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	buffering_state_ = 0;
	return t_val_parsing_complete;
	}

RegExMatcher HTTP_Status_re_008("[0-9]{3}");

HTTP_Status::HTTP_Status()
	{
	}

HTTP_Status::~HTTP_Status()
	{
	stat_str_.free();
	}

int HTTP_Status::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Parse "stat_str"
	int t_stat_str_string_length;
	t_stat_str_string_length = 
		HTTP_Status_re_008.MatchPrefix(
			t_begin_of_data,
			t_end_of_data - t_begin_of_data);
	if ( t_stat_str_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:85", "[0-9]{3}", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	int t_stat_str__size;
	t_stat_str__size = t_stat_str_string_length;
	// check for negative sizes
	if ( t_stat_str_string_length < 0 )
	throw ExceptionInvalidStringLength("http.pac:85", t_stat_str_string_length);
	stat_str_.init(t_begin_of_data, t_stat_str_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_HTTP_Status__size;
	const_byteptr const t_dataptr_after_stat_str = t_begin_of_data + (t_stat_str__size);
	BINPAC_ASSERT(t_dataptr_after_stat_str <= t_end_of_data);
	t_HTTP_Status__size = t_dataptr_after_stat_str - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	stat_num_ = bytestring_to_int(stat_str(), 10);
	BINPAC_ASSERT(t_begin_of_data + (t_HTTP_Status__size) <= t_end_of_data);
	return t_HTTP_Status__size;
	}

RegExMatcher HTTP_Version_re_010("[0-9]+\\.[0-9]+");

HTTP_Version::HTTP_Version()
	{
	}

HTTP_Version::~HTTP_Version()
	{
	vers_str_.free();
	}

int HTTP_Version::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "HTTP_Version:anonymous_field_009"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("HTTP_Version:anonymous_field_009",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "anonymous_field_009"
	bytestring anonymous_field_009_;
	if ( memcmp(t_begin_of_data, "HTTP/", 5) != 0 )
		{
		throw ExceptionStringMismatch("http.pac:91", "HTTP/", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_009_.free();
	
	// Parse "vers_str"
	int t_vers_str_string_length;
	t_vers_str_string_length = 
		HTTP_Version_re_010.MatchPrefix(
			(t_begin_of_data + 5),
			t_end_of_data - (t_begin_of_data + 5));
	if ( t_vers_str_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:92", "[0-9]+\\.[0-9]+", string((const char *) ((t_begin_of_data + 5)), (const char *) t_end_of_data).c_str());
		}
	int t_vers_str__size;
	t_vers_str__size = t_vers_str_string_length;
	// check for negative sizes
	if ( t_vers_str_string_length < 0 )
	throw ExceptionInvalidStringLength("http.pac:92", t_vers_str_string_length);
	vers_str_.init((t_begin_of_data + 5), t_vers_str_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	int t_HTTP_Version__size;
	const_byteptr const t_dataptr_after_vers_str = (t_begin_of_data + 5) + (t_vers_str__size);
	BINPAC_ASSERT(t_dataptr_after_vers_str <= t_end_of_data);
	t_HTTP_Version__size = t_dataptr_after_vers_str - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	vers_num_ = bytestring_to_double(vers_str());
	BINPAC_ASSERT(t_begin_of_data + (t_HTTP_Version__size) <= t_end_of_data);
	return t_HTTP_Version__size;
	}

HTTP_Headers::HTTP_Headers()
	{
	val_ = 0;
	val__elem_ = 0;
	buffering_state_ = 0;
	val__elem__it_ = -1;
	}

HTTP_Headers::~HTTP_Headers()
	{
	delete val__elem_;
	val__elem_ = 0;
	if ( val() )
		{
		for ( int i = 0; i < (int) val()->size(); ++i )
			{
			HTTP_Header * val__elem_ = (*val_)[i];
			delete val__elem_;
			val__elem_ = 0;
			}
		}
	delete val_;
	}

bool HTTP_Headers::ParseBuffer(flow_buffer_t t_flow_buffer)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	if ( val__elem__it_ < 0 )
		{
		// Initialize only once
		val__elem__it_ = 0;
		val_ = new vector<HTTP_Header *>;
		}
	for (; /* forever */; ++val__elem__it_)
		{
		if ( ! val__elem_ )
			{
			val__elem_ = new HTTP_Header();
			}
		if ( buffering_state_ == 0 )
			{
			t_flow_buffer->NewLine();
			buffering_state_ = 1;
			}
		bool t_val__elem_parsing_complete;
		t_val__elem_parsing_complete = false;
		while ( ! t_val__elem_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			const_bytestring t_val__elem_input(t_begin_of_data, t_end_of_data);
			// Check &until( ( @$input->length@() == ((int) 0) ) )
			if (  ( t_val__elem_input.length() == 0 )  )
				{
				t_val_parsing_complete = true;
				delete val__elem_;
				val__elem_ = 0;
				goto end_of_val;
				}
			t_val__elem_parsing_complete = val__elem_->ParseBuffer(t_flow_buffer);
			if ( t_val__elem_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			buffering_state_ = 0;
			}
		if ( ! t_val__elem_parsing_complete )
			goto need_more_data;
		val_->push_back(val__elem_);
		val__elem_ = 0;
		}
end_of_val: ;
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

HTTP_Message::HTTP_Message(ExpectBody expect_body)
	{
	headers_ = 0;
	body_or_not_case_index_ = -1;
	body_ = 0;
	expect_body_ = expect_body;
	parsing_state_ = 0;
	}

HTTP_Message::~HTTP_Message()
	{
	delete headers_;
	headers_ = 0;
	switch ( body_or_not_case_index() )
		{
		case 1:
			// Clean up "none"
			{
			}
			break;
		default:
			// Clean up "body"
			{
			delete body_;
			body_ = 0;
			}
			break;
		}
	}

bool HTTP_Message::ParseBuffer(flow_buffer_t t_flow_buffer, ContextHTTP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "headers"
		if ( ! headers_ )
			{
			headers_ = new HTTP_Headers();
			}
		parsing_state_ = 1;
	case 1:
		{
		bool t_headers_parsing_complete;
		t_headers_parsing_complete = false;
		t_headers_parsing_complete = headers_->ParseBuffer(t_flow_buffer);
		if ( t_headers_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_headers_parsing_complete) )
			goto need_more_data;
		}
		
		// Parse "body_or_not"
		parsing_state_ = 2;
	case 2:
		{
		bool t_body_or_not_parsing_complete;
		t_body_or_not_parsing_complete = false;
		body_or_not_case_index_ = expect_body();
		switch ( body_or_not_case_index() )
			{
			case 1:
				// Parse "none"
				{
				bool t_none_parsing_complete;
				t_none_parsing_complete = false;
				t_none_parsing_complete = true;
				t_body_or_not_parsing_complete = t_none_parsing_complete;
				}
				break;
			default:
				// Parse "body"
				{
				if ( ! body_ )
					{
					body_ = new HTTP_Body(expect_body());
					}
				bool t_body_parsing_complete;
				t_body_parsing_complete = false;
				t_body_parsing_complete = body_->ParseBuffer(t_flow_buffer, t_context);
				if ( t_body_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				t_body_or_not_parsing_complete = t_body_parsing_complete;
				}
				break;
			}
		if ( t_body_or_not_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_body_or_not_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

RegExMatcher HTTP_HEADER_NAME_re_011("|([^: \\t]+:)");

HTTP_Header::HTTP_Header()
	{
	buffering_state_ = 0;
	}

HTTP_Header::~HTTP_Header()
	{
	}

bool HTTP_Header::ParseBuffer(flow_buffer_t t_flow_buffer)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	// Parse "name"
	int t_name_string_length;
	t_name_string_length = 
		HTTP_HEADER_NAME_re_011.MatchPrefix(
			t_begin_of_data,
			t_end_of_data - t_begin_of_data);
	if ( t_name_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:113", "|([^: \\t]+:)", string((const char *) (t_begin_of_data), (const char *) t_end_of_data).c_str());
		}
	int t_name__size;
	t_name__size = t_name_string_length;
	// check for negative sizes
	if ( t_name_string_length < 0 )
	throw ExceptionInvalidStringLength("http.pac:113", t_name_string_length);
	name_.init(t_begin_of_data, t_name_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_name = t_begin_of_data + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	// Parse "anonymous_field_012"
	bytestring anonymous_field_012_;
	int t_anonymous_field_012_string_length;
	t_anonymous_field_012_string_length = 
		HTTP_WS_re_002.MatchPrefix(
			t_dataptr_after_name,
			t_end_of_data - t_dataptr_after_name);
	if ( t_anonymous_field_012_string_length < 0 )
		{
		throw ExceptionStringMismatch("http.pac:114", "[ \\t]*", string((const char *) (t_dataptr_after_name), (const char *) t_end_of_data).c_str());
		}
	int t_anonymous_field_012__size;
	t_anonymous_field_012__size = t_anonymous_field_012_string_length;
	// Evaluate 'let' and 'withinput' fields
	anonymous_field_012_.free();
	
	const_byteptr const t_dataptr_after_anonymous_field_012 = t_dataptr_after_name + (t_anonymous_field_012__size);
	BINPAC_ASSERT(t_dataptr_after_anonymous_field_012 <= t_end_of_data);
	// Parse "value"
	int t_value_string_length;
	t_value_string_length = (t_end_of_data) - (t_dataptr_after_anonymous_field_012);
	int t_value__size;
	t_value__size = t_value_string_length;
	// check for negative sizes
	if ( t_value_string_length < 0 )
	throw ExceptionInvalidStringLength("http.pac:115", t_value_string_length);
	value_.init(t_dataptr_after_anonymous_field_012, t_value_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	t_val_parsing_complete = true;
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	buffering_state_ = 0;
	return t_val_parsing_complete;
	}

MIME_Line::MIME_Line()
	{
	buffering_state_ = 0;
	}

MIME_Line::~MIME_Line()
	{
	}

bool MIME_Line::ParseBuffer(flow_buffer_t t_flow_buffer)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	const_byteptr t_begin_of_data = t_flow_buffer->begin();
	const_byteptr t_end_of_data = t_flow_buffer->end();
	// Parse "line"
	int t_line_string_length;
	t_line_string_length = (t_end_of_data) - (t_begin_of_data);
	int t_line__size;
	t_line__size = t_line_string_length;
	// check for negative sizes
	if ( t_line_string_length < 0 )
	throw ExceptionInvalidStringLength("http.pac:119", t_line_string_length);
	line_.init(t_begin_of_data, t_line_string_length);
	// Evaluate 'let' and 'withinput' fields
	
	t_val_parsing_complete = true;
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	buffering_state_ = 0;
	return t_val_parsing_complete;
	}

MIME_Lines::MIME_Lines()
	{
	val_ = 0;
	val__elem_ = 0;
	buffering_state_ = 0;
	val__elem__it_ = -1;
	}

MIME_Lines::~MIME_Lines()
	{
	delete val__elem_;
	val__elem_ = 0;
	if ( val() )
		{
		for ( int i = 0; i < (int) val()->size(); ++i )
			{
			MIME_Line * val__elem_ = (*val_)[i];
			delete val__elem_;
			val__elem_ = 0;
			}
		}
	delete val_;
	}

bool MIME_Lines::ParseBuffer(flow_buffer_t t_flow_buffer, ContextHTTP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	if ( val__elem__it_ < 0 )
		{
		// Initialize only once
		val__elem__it_ = 0;
		val_ = new vector<MIME_Line *>;
		}
	for (; /* forever */; ++val__elem__it_)
		{
		if ( ! val__elem_ )
			{
			val__elem_ = new MIME_Line();
			}
		if ( buffering_state_ == 0 )
			{
			t_flow_buffer->NewLine();
			buffering_state_ = 1;
			}
		bool t_val__elem_parsing_complete;
		t_val__elem_parsing_complete = false;
		while ( ! t_val__elem_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			const_bytestring t_val__elem_input(t_begin_of_data, t_end_of_data);
			// Check &until( ( @@$context->flow@->is_end_of_multipart@($input) ) )
			if (  ( t_context->flow()->is_end_of_multipart(t_val__elem_input) )  )
				{
				t_val_parsing_complete = true;
				delete val__elem_;
				val__elem_ = 0;
				goto end_of_val;
				}
			t_val__elem_parsing_complete = val__elem_->ParseBuffer(t_flow_buffer);
			if ( t_val__elem_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			buffering_state_ = 0;
			}
		if ( ! t_val__elem_parsing_complete )
			goto need_more_data;
		val_->push_back(val__elem_);
		val__elem_ = 0;
		}
end_of_val: ;
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

HTTP_Body::HTTP_Body(ExpectBody expect_body)
	{
	val_case_index_ = -1;
	buffering_state_ = 0;
	chunks_ = 0;
	multipart_ = 0;
	unknown_ = 0;
	expect_body_ = expect_body;
	}

HTTP_Body::~HTTP_Body()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "body"
			{
			}
			break;
		case 2:
			// Clean up "chunks"
			{
			delete chunks_;
			chunks_ = 0;
			}
			break;
		case 3:
			// Clean up "multipart"
			{
			delete multipart_;
			multipart_ = 0;
			}
			break;
		default:
			// Clean up "unknown"
			{
			delete unknown_;
			unknown_ = 0;
			}
			break;
		}
	}

bool HTTP_Body::ParseBuffer(flow_buffer_t t_flow_buffer, ContextHTTP * t_context)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	val_case_index_ = t_context->flow()->delivery_mode();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "body"
			{
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(0, true);
				buffering_state_ = 1;
				}
			bool t_body_parsing_complete;
			t_body_parsing_complete = false;
			while ( ! t_body_parsing_complete && t_flow_buffer->ready() )
				{
				const_byteptr t_begin_of_data = t_flow_buffer->begin();
				const_byteptr t_end_of_data = t_flow_buffer->end();
				switch ( buffering_state_ )
					{
					case 0:
						if ( buffering_state_ == 0 )
							{
							t_flow_buffer->NewFrame(0, true);
							buffering_state_ = 1;
							}
						buffering_state_ = 1;
						break;
					case 1:
						{
						buffering_state_ = 2;
						t_flow_buffer->GrowFrame(t_context->flow()->content_length());
						}
						break;
					case 2:
						BINPAC_ASSERT(t_flow_buffer->ready());
						if ( t_flow_buffer->ready() )
							{
							int t_body_string_length;
							t_body_string_length = t_context->flow()->content_length();
							// check for negative sizes
							if ( t_body_string_length < 0 )
							throw ExceptionInvalidStringLength("http.pac:130", t_body_string_length);
							body_.init(t_begin_of_data, t_body_string_length);
							t_body_parsing_complete = true;
							if ( t_body_parsing_complete )
								{
								// Evaluate 'let' and 'withinput' fields
								}
							BINPAC_ASSERT(t_body_parsing_complete);
							buffering_state_ = 0;
							}
						break;
					default:
						BINPAC_ASSERT(buffering_state_ <= 2);
						break;
					}
				}
			t_val_parsing_complete = t_body_parsing_complete;
			}
			break;
		case 2:
			// Parse "chunks"
			{
			if ( ! chunks_ )
				{
				chunks_ = new HTTP_Chunks();
				}
			bool t_chunks_parsing_complete;
			t_chunks_parsing_complete = false;
			t_chunks_parsing_complete = chunks_->ParseBuffer(t_flow_buffer);
			if ( t_chunks_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			t_val_parsing_complete = t_chunks_parsing_complete;
			}
			break;
		case 3:
			// Parse "multipart"
			{
			if ( ! multipart_ )
				{
				multipart_ = new MIME_Lines();
				}
			bool t_multipart_parsing_complete;
			t_multipart_parsing_complete = false;
			t_multipart_parsing_complete = multipart_->ParseBuffer(t_flow_buffer, t_context);
			if ( t_multipart_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			t_val_parsing_complete = t_multipart_parsing_complete;
			}
			break;
		default:
			// Parse "unknown"
			{
			if ( ! unknown_ )
				{
				unknown_ = new HTTP_UnknownBody(expect_body());
				}
			bool t_unknown_parsing_complete;
			t_unknown_parsing_complete = false;
			t_unknown_parsing_complete = unknown_->ParseBuffer(t_flow_buffer);
			if ( t_unknown_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			t_val_parsing_complete = t_unknown_parsing_complete;
			}
			break;
		}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	return t_val_parsing_complete;
	}

HTTP_UnknownBody::HTTP_UnknownBody(ExpectBody expect_body)
	{
	val_case_index_ = -1;
	buffering_state_ = 0;
	expect_body_ = expect_body;
	}

HTTP_UnknownBody::~HTTP_UnknownBody()
	{
	switch ( val_case_index() )
		{
		case 2:
		case 1:
			// Clean up "maybenot"
			{
			}
			break;
		case 0:
			// Clean up "rest"
			{
			}
			break;
		}
	}

bool HTTP_UnknownBody::ParseBuffer(flow_buffer_t t_flow_buffer)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	val_case_index_ = expect_body();
	switch ( val_case_index() )
		{
		case 2:
		case 1:
			// Parse "maybenot"
			{
			bool t_maybenot_parsing_complete;
			t_maybenot_parsing_complete = false;
			t_maybenot_parsing_complete = true;
			t_val_parsing_complete = t_maybenot_parsing_complete;
			}
			break;
		case 0:
			// Parse "rest"
			{
			if ( buffering_state_ == 0 )
				{
				t_flow_buffer->NewFrame(-1, true);
				buffering_state_ = 1;
				}
			bool t_rest_parsing_complete;
			t_rest_parsing_complete = false;
			while ( ! t_rest_parsing_complete && t_flow_buffer->ready() )
				{
				const_byteptr t_begin_of_data = t_flow_buffer->begin();
				const_byteptr t_end_of_data = t_flow_buffer->end();
				BINPAC_ASSERT(t_flow_buffer->eof());
				int t_rest_string_length;
				t_rest_string_length = (t_end_of_data) - (t_begin_of_data);
				// check for negative sizes
				if ( t_rest_string_length < 0 )
				throw ExceptionInvalidStringLength("http.pac:142", t_rest_string_length);
				rest_.init(t_begin_of_data, t_rest_string_length);
				t_rest_parsing_complete = true;
				if ( t_rest_parsing_complete )
					{
					// Evaluate 'let' and 'withinput' fields
					}
				}
			t_val_parsing_complete = t_rest_parsing_complete;
			}
			break;
		default:
			throw ExceptionInvalidCaseIndex("HTTP_UnknownBody", val_case_index());
			break;
		}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	return t_val_parsing_complete;
	}

HTTP_Chunks::HTTP_Chunks()
	{
	chunks_ = 0;
	chunks__elem_ = 0;
	chunks__elem__it_ = -1;
	headers_ = 0;
	parsing_state_ = 0;
	}

HTTP_Chunks::~HTTP_Chunks()
	{
	delete chunks__elem_;
	chunks__elem_ = 0;
	if ( chunks() )
		{
		for ( int i = 0; i < (int) chunks()->size(); ++i )
			{
			HTTP_Chunk * chunks__elem_ = (*chunks_)[i];
			delete chunks__elem_;
			chunks__elem_ = 0;
			}
		}
	delete chunks_;
	delete headers_;
	headers_ = 0;
	}

bool HTTP_Chunks::ParseBuffer(flow_buffer_t t_flow_buffer)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "chunks"
		if ( ! chunks_ )
			{
			}
		parsing_state_ = 1;
	case 1:
		{
		bool t_chunks_parsing_complete;
		t_chunks_parsing_complete = false;
		if ( chunks__elem__it_ < 0 )
			{
			// Initialize only once
			chunks__elem__it_ = 0;
			chunks_ = new vector<HTTP_Chunk *>;
			}
		for (; /* forever */; ++chunks__elem__it_)
			{
			if ( ! chunks__elem_ )
				{
				chunks__elem_ = new HTTP_Chunk();
				}
			bool t_chunks__elem_parsing_complete;
			t_chunks__elem_parsing_complete = false;
			t_chunks__elem_parsing_complete = chunks__elem_->ParseBuffer(t_flow_buffer);
			if ( t_chunks__elem_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			if ( ! t_chunks__elem_parsing_complete )
				goto need_more_data;
			chunks_->push_back(chunks__elem_);
			// Check &until( ( @$element->chunk_length@ == ((int) 0) ) )
			if (  ( chunks__elem_->chunk_length() == 0 )  )
				{
				t_chunks_parsing_complete = true;
				chunks__elem_ = 0;
				goto end_of_chunks;
				}
			chunks__elem_ = 0;
			}
	end_of_chunks: ;
		if ( t_chunks_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_chunks_parsing_complete) )
			goto need_more_data;
		}
		
		// Parse "headers"
		if ( ! headers_ )
			{
			headers_ = new HTTP_Headers();
			}
		parsing_state_ = 2;
	case 2:
		{
		bool t_headers_parsing_complete;
		t_headers_parsing_complete = false;
		t_headers_parsing_complete = headers_->ParseBuffer(t_flow_buffer);
		if ( t_headers_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_headers_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

HTTP_Chunk::HTTP_Chunk()
	{
	buffering_state_ = 0;
	opt_crlf_case_index_ = -1;
	parsing_state_ = 0;
	}

HTTP_Chunk::~HTTP_Chunk()
	{
	length_line_.free();
	switch ( opt_crlf_case_index() )
		{
		case 0:
			// Clean up "none"
			{
			}
			break;
		default:
			// Clean up "crlf"
			{
			crlf_.free();
			}
			break;
		}
	}

bool HTTP_Chunk::ParseBuffer(flow_buffer_t t_flow_buffer)
	{
	bool t_val_parsing_complete;
	t_val_parsing_complete = false;
	switch ( parsing_state_ ) {
	case 0:
		// Parse "length_line"
		if ( buffering_state_ == 0 )
			{
			t_flow_buffer->NewLine();
			buffering_state_ = 1;
			}
		parsing_state_ = 1;
	case 1:
		{
		bool t_length_line_parsing_complete;
		t_length_line_parsing_complete = false;
		while ( ! t_length_line_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			int t_length_line_string_length;
			t_length_line_string_length = (t_end_of_data) - (t_begin_of_data);
			// check for negative sizes
			if ( t_length_line_string_length < 0 )
			throw ExceptionInvalidStringLength("http.pac:151", t_length_line_string_length);
			length_line_.init(t_begin_of_data, t_length_line_string_length);
			t_length_line_parsing_complete = true;
			if ( t_length_line_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			buffering_state_ = 0;
			}
		if ( ! (t_length_line_parsing_complete) )
			goto need_more_data;
		}
		
		// Parse "data"
		t_flow_buffer->NewFrame(-1, true);
		parsing_state_ = 2;
	case 2:
		{
		bool t_data_parsing_complete;
		t_data_parsing_complete = false;
		while ( ! t_data_parsing_complete && t_flow_buffer->ready() )
			{
			const_byteptr t_begin_of_data = t_flow_buffer->begin();
			const_byteptr t_end_of_data = t_flow_buffer->end();
			switch ( buffering_state_ )
				{
				case 0:
					t_flow_buffer->NewFrame(-1, true);
					buffering_state_ = 1;
					break;
				case 1:
					{
					buffering_state_ = 2;
					chunk_length_ = bytestring_to_int(length_line(), 16);
					t_flow_buffer->GrowFrame(chunk_length());
					}
					break;
				case 2:
					BINPAC_ASSERT(t_flow_buffer->ready());
					if ( t_flow_buffer->ready() )
						{
						int t_data_string_length;
						t_data_string_length = chunk_length();
						// check for negative sizes
						if ( t_data_string_length < 0 )
						throw ExceptionInvalidStringLength("http.pac:152", t_data_string_length);
						data_.init(t_begin_of_data, t_data_string_length);
						t_data_parsing_complete = true;
						if ( t_data_parsing_complete )
							{
							// Evaluate 'let' and 'withinput' fields
							}
						BINPAC_ASSERT(t_data_parsing_complete);
						buffering_state_ = 0;
						}
					break;
				default:
					BINPAC_ASSERT(buffering_state_ <= 2);
					break;
				}
			}
		if ( ! (t_data_parsing_complete) )
			goto need_more_data;
		}
		
		// Parse "opt_crlf"
		parsing_state_ = 3;
	case 3:
		{
		bool t_opt_crlf_parsing_complete;
		t_opt_crlf_parsing_complete = false;
		opt_crlf_case_index_ = chunk_length();
		switch ( opt_crlf_case_index() )
			{
			case 0:
				// Parse "none"
				{
				bool t_none_parsing_complete;
				t_none_parsing_complete = false;
				t_none_parsing_complete = true;
				t_opt_crlf_parsing_complete = t_none_parsing_complete;
				}
				break;
			default:
				// Parse "crlf"
				{
				if ( buffering_state_ == 0 )
					{
					t_flow_buffer->NewLine();
					buffering_state_ = 1;
					}
				bool t_crlf_parsing_complete;
				t_crlf_parsing_complete = false;
				while ( ! t_crlf_parsing_complete && t_flow_buffer->ready() )
					{
					const_byteptr t_begin_of_data = t_flow_buffer->begin();
					const_byteptr t_end_of_data = t_flow_buffer->end();
					int t_crlf_string_length;
					t_crlf_string_length = (t_end_of_data) - (t_begin_of_data);
					// check for negative sizes
					if ( t_crlf_string_length < 0 )
					throw ExceptionInvalidStringLength("http.pac:155", t_crlf_string_length);
					crlf_.init(t_begin_of_data, t_crlf_string_length);
					t_crlf_parsing_complete = true;
					if ( t_crlf_parsing_complete )
						{
						// Evaluate 'let' and 'withinput' fields
						}
					buffering_state_ = 0;
					}
				t_opt_crlf_parsing_complete = t_crlf_parsing_complete;
				}
				break;
			}
		if ( t_opt_crlf_parsing_complete )
			{
			// Evaluate 'let' and 'withinput' fields
			}
		if ( ! (t_opt_crlf_parsing_complete) )
			goto need_more_data;
		}
		
		
		t_val_parsing_complete = true;
	}
	if ( t_val_parsing_complete )
		{
		// Evaluate 'let' and 'withinput' fields
		}
	BINPAC_ASSERT(t_val_parsing_complete);
	return t_val_parsing_complete;
	
need_more_data:
	BINPAC_ASSERT(!(t_val_parsing_complete));
	return false;
	}

HTTP_Conn::HTTP_Conn(BaseConn * http_conn)
	{
	upflow_ = new HTTP_Flow(this, true);
	downflow_ = new HTTP_Flow(this, false);
	http_conn_ = http_conn;
	}

HTTP_Conn::~HTTP_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void HTTP_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void HTTP_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void HTTP_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

HTTP_Flow::HTTP_Flow(HTTP_Conn * connection, bool is_orig)
	{
	flow_buffer_ = 0;
	connection_ = connection;
	is_orig_ = is_orig;

    content_length_ = 0;
    delivery_mode_ = UNKNOWN_DELIVERY_MODE;

    msg_start_time_ = 0;
    msg_begin_seq_ = 0;
    msg_header_end_seq_ = -1;

  
	dataunit_ = 0;
	context_ = 0;
	flow_buffer_ = new FlowBuffer();
	}

HTTP_Flow::~HTTP_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;

    end_of_multipart_.free();
  
	delete flow_buffer_;
	flow_buffer_ = 0;
	}

void HTTP_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		flow_buffer_->NewData(t_begin_of_data, t_end_of_data);
		while ( flow_buffer_->data_available() && 
			( !flow_buffer_->have_pending_request() || flow_buffer_->ready() ) )
			{
			if ( ! dataunit_ )
				{
				BINPAC_ASSERT(!context_);
				dataunit_ = new HTTP_PDU(is_orig());
				context_ = new ContextHTTP(connection(), this, flow_buffer_);
				}
			bool t_dataunit_parsing_complete;
			t_dataunit_parsing_complete = false;
			t_dataunit_parsing_complete = dataunit_->ParseBuffer(flow_buffer_, context_);
			if ( t_dataunit_parsing_complete )
				{
				// Evaluate 'let' and 'withinput' fields
				}
			if ( t_dataunit_parsing_complete )
				{
				// Clean up the flow unit after parsing
				delete dataunit_;
				dataunit_ = 0;
				delete context_;
				context_ = 0;
				}
			else
				{
				// Resume upon next input segment
				BINPAC_ASSERT(!flow_buffer_->ready());
				break;
				}
			}
		}
	catch ( Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;

    end_of_multipart_.free();
  
		flow_buffer_->DiscardData();
		throw e;
		}
	}

void HTTP_Flow::NewGap(int gap_length)
	{
	flow_buffer_->NewGap(gap_length);
	}
void HTTP_Flow::FlowEOF()
	{
	flow_buffer_->set_eof();
	NewData(0, 0);
	}
int HTTP_Flow::content_length()
	{

    return content_length_;
    
	}

DeliveryMode HTTP_Flow::delivery_mode()
	{

    return delivery_mode_;
    
	}

const_bytestring HTTP_Flow::end_of_multipart()
	{

    return end_of_multipart_;
    
	}

bool HTTP_Flow::is_end_of_multipart(const_bytestring const & line)
	{

    if ( line.length() < 4 + end_of_multipart_.length() )
      return false;

    int len = end_of_multipart_.length();

    // line =?= "--" end_of_multipart_ "--"
    return ( line[0] == '-' && line[1] == '-' &&
       line[len + 2] == '-' && line[len + 3] == '-' &&
       strncmp((const char*) line.begin() + 2,
        (const char*) end_of_multipart_.begin(),
        len) == 0 );
    
	}

  int events = 0;

bool scb_store_method_uri_version(BaseConn * conn, bool is_orig, const_bytestring const & method, const_bytestring const & uri, const_bytestring const & version)
	{

  
  //
  // Store the parsed fields
  //  
	  //	  strcpy(conn->method, std_string(method).c_str());
	  //	  strcpy(conn->uri, std_string(uri).c_str());
	  //	  strcpy(conn->version, std_string(version).c_str());
	  printf ("e");
	  events += 3;
  return true;

	}

} // namespace HTTP
}  // namespace binpac
